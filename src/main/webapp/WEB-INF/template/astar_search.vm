<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>A*寻路算法</title>

    <link href="css/astar_search.css" rel="stylesheet"/>
    <script src="js/jquery-3.2.0.min.js"></script>
</head>
<body>
<div class="top_container">
    设置 : <input type="radio" name="pointType" value="1" checked>起点
    <input type="radio" name="pointType" value="2">终点
    <input type="radio" name="pointType" value="3">障碍物&nbsp;&nbsp;&nbsp;
    <input type="button" value="清除障碍物" onclick="clearHinders()">&nbsp;&nbsp;&nbsp;
    <input type="button" value="开始运算" onclick="starSearch()">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    X : <span id="x_coordinate">0</span>, Y : <span id="y_coordinate">0</span>,
    F : <span id="f_value">0</span>, G : <span id="g_value">0</span>, H : <span id="h_value">0</span>
</div>
<div id="path_map" class="center_container">
</div>
</body>

<script>
    $(function () {
        initMapBlock();
    });

    // 方块对象集合
    var pointArray = new Array();

    // 起点
    var begin_point = null;

    // 终点
    var end_point = null;

    // 当前F值最低方块
    var current_lowest_f_point = null;

    // 障碍物列表
    var hinderList = new Array();

    // 开启列表（待检查的方块列表）
    var openList = new Array();

    // 关闭列表（不需要检查的方块列表）
    var closeList = new Array();

    // 创建一个10*10的方格图
    function initMapBlock() {
        var blockHtml = "";
        for (var x = 1; x <= 100; x++) {
            blockHtml += "<div id=\"point_" + x + "\" class=\"point\" index=\"" + x
                    + "\" onclick=\"clickPoint(this)\" onmouseover=\"overPoint(this)\"></div>";

            // X坐标
            var x_coordinate = (x % 10 != 0) ? (x % 10) : 10;
            // Y坐标
            var y_coordinate = (x % 10 != 0) ? Math.ceil(x / 10) : (x / 10);
            // 方块对象
            var point = {
                index: x,
                x: x_coordinate,
                y: y_coordinate,
                f: 0, // f = g + h
                g: 0, // 表示从起点 A 移动到网格上指定方格的移动耗费
                h: 0, // 表示从指定的方格移动到终点 B 的预计耗费
                is_hinder: 0, // 是否是障碍(0:否,1:是)
                is_begin: 0, // 是否是起点(0:否,1:是)
                is_end: 0, // 是否是终点(0:否,1:是)
                parent_point: null // 父方格
            };
            pointArray.push(point);
        }
        $("#path_map").html(blockHtml);
    }

    // 清除障碍物
    function clearHinders() {
        for (var x = 0; x < hinderList.length; x++) {
            var p = hinderList[x];
            p.is_hinder = 0;
            $("div[index='" + p.index + "']").removeClass("hinder");
        }
        hinderList.splice(0, hinderList.length);
    }

    // 设置起点、终点和障碍物
    function clickPoint(point) {
        var cur_point = $(point);
        var index = cur_point.attr("index");
        var pointType = $("input[type='radio'][name='pointType']:checked").val();
        if (pointType == 1) { // 起点
            // 如果已经有起点，去掉之前的起点
            for (var x = 0; x < pointArray.length; x++) {
                var p = pointArray[x];
                if (p.is_begin == 1) {
                    p.is_begin = 0;
                    $("div[index='" + p.index + "']").removeClass("begin");
                    break;
                }
            }
            // 将当前选择的方块设置为起点
            for (var x = 0; x < pointArray.length; x++) {
                var p = pointArray[x];
                if (p.index == index) {
                    p.is_begin = 1;
                    p.is_hinder = 0;
                    p.is_end = 0;
                    cur_point.removeClass("hinder").removeClass("end").addClass("begin");
                    begin_point = p;
                    break;
                }
            }
        } else if (pointType == 2) { // 终点
            // 如果已经有终点，去掉之前的终点
            for (var x = 0; x < pointArray.length; x++) {
                var p = pointArray[x];
                if (p.is_end == 1) {
                    p.is_end = 0;
                    $("div[index='" + p.index + "']").removeClass("end");
                    break;
                }
            }
            // 将当前选择的方块设置为终点
            for (var x = 0; x < pointArray.length; x++) {
                var p = pointArray[x];
                if (p.index == index) {
                    p.is_begin = 0;
                    p.is_hinder = 0;
                    p.is_end = 1;
                    cur_point.removeClass("hinder").removeClass("begin").addClass("end");
                    end_point = p;
                    break;
                }
            }
        } else if (pointType == 3) { // 障碍物
            // 将当前选择的方块设置为障碍物
            for (var x = 0; x < pointArray.length; x++) {
                var p = pointArray[x];
                if (p.index == index) {
                    p.is_begin = 0;
                    p.is_hinder = 1;
                    p.is_end = 0;
                    cur_point.removeClass("begin").removeClass("end").addClass("hinder");
                    hinderList.push(p);
                    break;
                }
            }
        }
    }

    // 鼠标移入方块
    function overPoint(point) {
        var cur_point = $(point);
        var index = cur_point.attr("index");
        for (var x = 0; x < pointArray.length; x++) {
            var p = pointArray[x];
            if (p.index == index) {
                $("#x_coordinate").text(p.x);
                $("#y_coordinate").text(p.y);
                $("#f_value").text(p.f);
                $("#g_value").text(p.g);
                $("#h_value").text(p.h);
                break;
            }
        }
    }

    // 检查是否可以开始寻路计算
    function checkSearch() {
        if (begin_point == null) {
            alert("请设置起点");
            return false;
        }
        if (end_point == null) {
            alert("请设置终点");
            return false;
        }
        if (hinderList.length == 0) {
            alert("请设置障碍物");
            return false;
        }
        return true;
    }

    // A*寻路计算
    function starSearch() {
        if (!checkSearch()) {
            return;
        }
        alert("开始计算");

        // 将起点放入开启列表
        openList.push(begin_point);
        coreCalculate();
    }

    // 寻找当前开启列表中找到F值最低的方格，暂记为C。
    // 将C从“开启列表”中删除，放入“关闭列表”。
    // 查找C所有相邻并且可以到达 (障碍物和“关闭列表”的方格都不考虑) 的方格，
    // 对于每一个可到达的方格，如果还不在“开启列表”里，将它加入 "开启列表"，计算其G，H和F值，并设置它的“父方格”为C。
    // 如果已经在“开启列表”里，计算新的G值(经过C到达它的路径)，如果新的G值比原G值小，就把它的 "父方格" 改为C，再重新计算它的F值和G值
    function coreCalculate() {
        var lowest_f_value = -1;
        var lowest_f_value_index = 0;
        for(var x in openList) {
            var p = openList[x];
            if(lowest_f_value == -1) {
                lowest_f_value = p.f;
            }
        }
    }
</script>
</html>
